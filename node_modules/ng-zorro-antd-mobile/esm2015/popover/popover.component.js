import { __decorate, __metadata } from "tslib";
import { Component, ViewEncapsulation } from '@angular/core';
import { PopoverComponentOptions } from './popover-component-options.provider';
let PopoverComponent = class PopoverComponent {
    constructor(options) {
        this.options = options;
        this.defaultProps = {
            prefixCls: 'am-popover'
        };
        this.maskCls = {};
        this.popoverCls = {};
    }
    setClassMap() {
        this.maskCls = {
            [`${this.defaultProps.prefixCls}-mask`]: this.options.mask,
            [`${this.defaultProps.prefixCls}-mask-hidden`]: !this.options.mask
        };
        this.popoverCls = {
            [`${this.defaultProps.prefixCls}`]: true,
            [`${this.defaultProps.prefixCls}-placement-${this.options.placement}`]: true,
            [`${this.defaultProps.prefixCls}-${this.options.className}`]: true
        };
    }
    ngOnInit() {
        this.setClassMap();
    }
    ngAfterViewInit() {
        this.options.onAfterViewInit();
    }
};
PopoverComponent.ctorParameters = () => [
    { type: PopoverComponentOptions }
];
PopoverComponent = __decorate([
    Component({
        selector: 'Popover',
        template: "<ng-content></ng-content>\n<div [ngClass]=\"maskCls\" (click)=\"options.hidePopover()\"></div>\n<div [ngClass]=\"popoverCls\" style=\"color: currentcolor;\">\n  <div class=\"{{ defaultProps.prefixCls }}-content\">\n    <div *ngIf=\"options.showArrow\" class=\"{{ defaultProps.prefixCls }}-arrow\"></div>\n    <div class=\"{{ defaultProps.prefixCls }}-inner\">\n      <div class=\"{{ defaultProps.prefixCls }}-inner-wrapper\">\n        <ng-template [ngTemplateOutlet]=\"options.overlay\" [ngTemplateOutletContext]=\"{ options: options }\">\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>\n",
        encapsulation: ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [PopoverComponentOptions])
], PopoverComponent);
export { PopoverComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy16b3Jyby1hbnRkLW1vYmlsZS8iLCJzb3VyY2VzIjpbInBvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWlCLGlCQUFpQixFQUFVLE1BQU0sZUFBZSxDQUFDO0FBQ3BGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBTy9FLElBQWEsZ0JBQWdCLEdBQTdCLE1BQWEsZ0JBQWdCO0lBTzNCLFlBQW1CLE9BQWdDO1FBQWhDLFlBQU8sR0FBUCxPQUFPLENBQXlCO1FBTm5ELGlCQUFZLEdBQVE7WUFDbEIsU0FBUyxFQUFFLFlBQVk7U0FDeEIsQ0FBQztRQUNGLFlBQU8sR0FBUSxFQUFFLENBQUM7UUFDbEIsZUFBVSxHQUFRLEVBQUUsQ0FBQztJQUVpQyxDQUFDO0lBRXZELFdBQVc7UUFDVCxJQUFJLENBQUMsT0FBTyxHQUFHO1lBQ2IsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUk7WUFDMUQsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxjQUFjLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSTtTQUNuRSxDQUFDO1FBQ0YsSUFBSSxDQUFDLFVBQVUsR0FBRztZQUNoQixDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLElBQUk7WUFDeEMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxjQUFjLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxJQUFJO1lBQzVFLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsSUFBSTtTQUNuRSxDQUFDO0lBQ0osQ0FBQztJQUVELFFBQVE7UUFDTixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUNELGVBQWU7UUFDYixJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ2pDLENBQUM7Q0FDRixDQUFBOztZQXBCNkIsdUJBQXVCOztBQVB4QyxnQkFBZ0I7SUFMNUIsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLFNBQVM7UUFDbkIsNG1CQUF1QztRQUN2QyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtLQUN0QyxDQUFDO3FDQVE0Qix1QkFBdUI7R0FQeEMsZ0JBQWdCLENBMkI1QjtTQTNCWSxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEFmdGVyVmlld0luaXQsIFZpZXdFbmNhcHN1bGF0aW9uLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBvcG92ZXJDb21wb25lbnRPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLWNvbXBvbmVudC1vcHRpb25zLnByb3ZpZGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnUG9wb3ZlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9wb3BvdmVyLmNvbXBvbmVudC5odG1sJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgZGVmYXVsdFByb3BzOiBhbnkgPSB7XG4gICAgcHJlZml4Q2xzOiAnYW0tcG9wb3ZlcidcbiAgfTtcbiAgbWFza0NsczogYW55ID0ge307XG4gIHBvcG92ZXJDbHM6IGFueSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25zOiBQb3BvdmVyQ29tcG9uZW50T3B0aW9ucykge31cblxuICBzZXRDbGFzc01hcCgpIHtcbiAgICB0aGlzLm1hc2tDbHMgPSB7XG4gICAgICBbYCR7dGhpcy5kZWZhdWx0UHJvcHMucHJlZml4Q2xzfS1tYXNrYF06IHRoaXMub3B0aW9ucy5tYXNrLFxuICAgICAgW2Ake3RoaXMuZGVmYXVsdFByb3BzLnByZWZpeENsc30tbWFzay1oaWRkZW5gXTogIXRoaXMub3B0aW9ucy5tYXNrXG4gICAgfTtcbiAgICB0aGlzLnBvcG92ZXJDbHMgPSB7XG4gICAgICBbYCR7dGhpcy5kZWZhdWx0UHJvcHMucHJlZml4Q2xzfWBdOiB0cnVlLFxuICAgICAgW2Ake3RoaXMuZGVmYXVsdFByb3BzLnByZWZpeENsc30tcGxhY2VtZW50LSR7dGhpcy5vcHRpb25zLnBsYWNlbWVudH1gXTogdHJ1ZSxcbiAgICAgIFtgJHt0aGlzLmRlZmF1bHRQcm9wcy5wcmVmaXhDbHN9LSR7dGhpcy5vcHRpb25zLmNsYXNzTmFtZX1gXTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnNldENsYXNzTWFwKCk7XG4gIH1cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9ucy5vbkFmdGVyVmlld0luaXQoKTtcbiAgfVxufVxuIl19