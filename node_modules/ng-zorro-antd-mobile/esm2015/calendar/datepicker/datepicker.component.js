import { __decorate, __metadata } from "tslib";
import { Component, HostBinding, ViewEncapsulation, Input, ElementRef, ViewChild } from '@angular/core';
import { CalendarDatePickerBaseComponent } from './datepicker.base.component';
let CalendarDatePickerComponent = class CalendarDatePickerComponent extends CalendarDatePickerBaseComponent {
    constructor() {
        super();
        this.transform = '';
        this._initDelta = 0;
        this._lastY = 0;
        this._delta = this._initDelta;
        this.amCalendar = true;
        this.datePicker = true;
        this.genMonthComponent = (data) => {
            if (!data) {
                return;
            }
            return {
                monthData: data,
                locale: this.props.locale,
                rowSize: this.props.rowSize,
                onCellClick: this.baseOnCellClick,
                getDateExtra: this.props.getDateExtra,
                ref: dom => {
                    data.componentRef = dom || data.componentRef || undefined;
                    data.updateLayout = () => {
                        this.computeHeight(data, dom);
                    };
                    data.updateLayout();
                }
            };
        };
        this.computeHeight = (data, singleMonth) => {
            if (singleMonth && singleMonth.wrapperDivDOM) {
                if (!data.height && !singleMonth.wrapperDivDOM.clientHeight) {
                    setTimeout(() => this.computeHeight(data, singleMonth), 500);
                    return;
                }
                data.height = singleMonth.wrapperDivDOM.clientHeight || data.height || 0;
                data.y = singleMonth.wrapperDivDOM.offsetTop || data.y || 0;
            }
        };
        this.setLayout = (dom) => {
            if (dom) {
                const { onLayout } = this.props;
                if (onLayout) {
                    onLayout(dom.clientHeight);
                }
                const scrollHandler = this.createOnScroll();
                dom.onscroll = evt => {
                    scrollHandler({
                        client: dom.clientHeight,
                        full: evt.currentTarget.clientHeight,
                        top: evt.currentTarget.scrollTop
                    });
                };
            }
        };
        this.setPanel = (dom) => {
            this._panel = dom;
        };
    }
    set onCellClick(value) {
        this.props.onCellClick = value;
    }
    set endDate(value) {
        const oldProps = Object.assign({}, this.props);
        this.props.endDate = value;
        this.receiveProps(oldProps, this.props);
    }
    set startDate(value) {
        const oldProps = Object.assign({}, this.props);
        this.props.startDate = value;
        this.receiveProps(oldProps, this.props);
    }
    set propsData(value) {
        this.props = Object.assign(Object.assign({}, this.props), value);
    }
    set onSelectHasDisableDate(value) {
        this.props.onSelectHasDisableDate = value;
    }
    set onLayout(value) {
        this.props.onLayout = value;
    }
    onTouchStart(event) {
        this._lastY = event.touches[0].screenY || event.touches[0].pageY;
        this._delta = this._initDelta;
    }
    onTouchMove(event) {
        const ele = event.currentTarget;
        const isReachTop = ele.scrollTop === 0;
        if (isReachTop) {
            this._delta = (event.touches[0].screenY || event.touches[0].pageY) - this._lastY;
            if (this._delta > 0) {
                event.preventDefault();
                if (this._delta > 80) {
                    this._delta = 80;
                }
            }
            else {
                this._delta = 0;
            }
            this.setTransform(this._panel.style, `translate3d(0,${this._delta}px,0)`);
        }
    }
    onTouchEnd(event) {
        this.onFinish();
    }
    onFinish() {
        if (this._delta > 40 && this.canLoadPrev()) {
            this.genMonthData(this.state.months[0].firstDate, -1);
            this.visibleMonth = this.state.months.slice(0, this.props.initalMonths);
            this.state.months.forEach(m => {
                if (m.updateLayout) {
                    m.updateLayout();
                }
            });
        }
        this.setTransform(this._panel.style, `translate3d(0,0,0)`);
        this.setTransition(this._panel.style, '.3s');
        setTimeout(() => {
            if (this._panel) {
                this.setTransition(this._panel.style, '');
            }
        }, 300);
    }
    setTransform(nodeStyle, value) {
        this.transform = value;
        nodeStyle.transform = value;
        nodeStyle.webkitTransform = value;
    }
    setTransition(nodeStyle, value) {
        nodeStyle.transition = value;
        nodeStyle.webkitTransition = value;
    }
    ngOnInit() {
        this.init();
        this.setLayout(this.layoutDom.nativeElement);
        this.setPanel(this.panelDom.nativeElement);
    }
};
__decorate([
    ViewChild('layout', { static: true }),
    __metadata("design:type", ElementRef)
], CalendarDatePickerComponent.prototype, "layoutDom", void 0);
__decorate([
    ViewChild('panel', { static: true }),
    __metadata("design:type", ElementRef)
], CalendarDatePickerComponent.prototype, "panelDom", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "onCellClick", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "endDate", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "startDate", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "propsData", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "onSelectHasDisableDate", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CalendarDatePickerComponent.prototype, "onLayout", null);
__decorate([
    HostBinding('class.am-calendar'),
    __metadata("design:type", Boolean)
], CalendarDatePickerComponent.prototype, "amCalendar", void 0);
__decorate([
    HostBinding('class.date-picker'),
    __metadata("design:type", Boolean)
], CalendarDatePickerComponent.prototype, "datePicker", void 0);
CalendarDatePickerComponent = __decorate([
    Component({
        selector: 'CalendarDatePicker, nzm-calendar-date-picker',
        template: "<CalendarWeekPanel [locale]=\"props.locale\"></CalendarWeekPanel>\n<div\n  #layout\n  class=\"wrapper\"\n  style=\"overflow-x:hidden;overflow-y:visible;-webkit-overflow-scrolling:touch;\"\n  (touchstart)=\"onTouchStart($event)\"\n  (touchmove)=\"onTouchMove($event)\"\n  (touchend)=\"onTouchEnd($event)\"\n>\n  <div #panel [ngStyle]=\"{ transform: transform }\">\n    <div *ngIf=\"canLoadPrev()\" class=\"load-tip\">{{ props.locale.loadPrevMonth }}</div>\n    <div class=\"months\">\n      <CalendarSingleMonth\n        *ngFor=\"let item of visibleMonth; let i = index\"\n        style=\"display: block;\"\n        [data]=\"item.component\"\n      ></CalendarSingleMonth>\n    </div>\n  </div>\n</div>\n",
        encapsulation: ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [])
], CalendarDatePickerComponent);
export { CalendarDatePickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy16b3Jyby1hbnRkLW1vYmlsZS8iLCJzb3VyY2VzIjpbImNhbGVuZGFyL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFVLGlCQUFpQixFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWhILE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBTzlFLElBQWEsMkJBQTJCLEdBQXhDLE1BQWEsMkJBQTRCLFNBQVEsK0JBQStCO0lBQzlFO1FBQ0UsS0FBSyxFQUFFLENBQUM7UUFHVixjQUFTLEdBQVcsRUFBRSxDQUFDO1FBRWYsZUFBVSxHQUFXLENBQUMsQ0FBQztRQUN2QixXQUFNLEdBQVcsQ0FBQyxDQUFDO1FBQ25CLFdBQU0sR0FBVyxJQUFJLENBQUMsVUFBVSxDQUFDO1FBdUNQLGVBQVUsR0FBWSxJQUFJLENBQUM7UUFDM0IsZUFBVSxHQUFZLElBQUksQ0FBQztRQUU3RCxzQkFBaUIsR0FBRyxDQUFDLElBQTJCLEVBQUUsRUFBRTtZQUNsRCxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNULE9BQU87YUFDUjtZQUNELE9BQU87Z0JBQ0wsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTTtnQkFDekIsT0FBTyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTztnQkFDM0IsV0FBVyxFQUFFLElBQUksQ0FBQyxlQUFlO2dCQUNqQyxZQUFZLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZO2dCQUNyQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUU7b0JBQ1QsSUFBSSxDQUFDLFlBQVksR0FBRyxHQUFHLElBQUksSUFBSSxDQUFDLFlBQVksSUFB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RSw4Q0FBOEM7UUFDeEQsMnNCQUEwQztRQUMxQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtLQUN0QyxDQUFDOztHQUNXLDJCQUEyQixDQXlLdkM7U0F6S1ksMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiwgSW5wdXQsIEVsZW1lbnRSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZU1vZGVscyB9IGZyb20gJy4uL2RhdGUvRGF0YVR5cGVzJztcbmltcG9ydCB7IENhbGVuZGFyRGF0ZVBpY2tlckJhc2VDb21wb25lbnQgfSBmcm9tICcuL2RhdGVwaWNrZXIuYmFzZS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdDYWxlbmRhckRhdGVQaWNrZXIsIG56bS1jYWxlbmRhci1kYXRlLXBpY2tlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlcGlja2VyLmNvbXBvbmVudC5odG1sJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBDYWxlbmRhckRhdGVQaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBDYWxlbmRhckRhdGVQaWNrZXJCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHRyYW5zZm9ybTogc3RyaW5nID0gJyc7XG4gIHByaXZhdGUgX3BhbmVsOiBhbnk7XG4gIHByaXZhdGUgX2luaXREZWx0YTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfbGFzdFk6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2RlbHRhOiBudW1iZXIgPSB0aGlzLl9pbml0RGVsdGE7XG5cbiAgQFZpZXdDaGlsZCgnbGF5b3V0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgbGF5b3V0RG9tOiBFbGVtZW50UmVmO1xuICBAVmlld0NoaWxkKCdwYW5lbCcsIHsgc3RhdGljOiB0cnVlIH0pXG4gIHBhbmVsRG9tOiBFbGVtZW50UmVmO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBvbkNlbGxDbGljayh2YWx1ZSkge1xuICAgIHRoaXMucHJvcHMub25DZWxsQ2xpY2sgPSB2YWx1ZTtcbiAgfVxuICBASW5wdXQoKVxuICBzZXQgZW5kRGF0ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9sZFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5wcm9wcy5lbmREYXRlID0gdmFsdWU7XG4gICAgdGhpcy5yZWNlaXZlUHJvcHMob2xkUHJvcHMsIHRoaXMucHJvcHMpO1xuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBzdGFydERhdGUodmFsdWUpIHtcbiAgICBjb25zdCBvbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuICAgIHRoaXMucHJvcHMuc3RhcnREYXRlID0gdmFsdWU7XG4gICAgdGhpcy5yZWNlaXZlUHJvcHMob2xkUHJvcHMsIHRoaXMucHJvcHMpO1xuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBwcm9wc0RhdGEodmFsdWUpIHtcbiAgICB0aGlzLnByb3BzID0ge1xuICAgICAgLi4udGhpcy5wcm9wcyxcbiAgICAgIC4uLnZhbHVlXG4gICAgfTtcbiAgfVxuICBASW5wdXQoKVxuICBzZXQgb25TZWxlY3RIYXNEaXNhYmxlRGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMucHJvcHMub25TZWxlY3RIYXNEaXNhYmxlRGF0ZSA9IHZhbHVlO1xuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBvbkxheW91dCh2YWx1ZSkge1xuICAgIHRoaXMucHJvcHMub25MYXlvdXQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3MuYW0tY2FsZW5kYXInKSBhbUNhbGVuZGFyOiBib29sZWFuID0gdHJ1ZTtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kYXRlLXBpY2tlcicpIGRhdGVQaWNrZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGdlbk1vbnRoQ29tcG9uZW50ID0gKGRhdGE/OiBEYXRlTW9kZWxzLk1vbnRoRGF0YSkgPT4ge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbW9udGhEYXRhOiBkYXRhLFxuICAgICAgbG9jYWxlOiB0aGlzLnByb3BzLmxvY2FsZSxcbiAgICAgIHJvd1NpemU6IHRoaXMucHJvcHMucm93U2l6ZSxcbiAgICAgIG9uQ2VsbENsaWNrOiB0aGlzLmJhc2VPbkNlbGxDbGljayxcbiAgICAgIGdldERhdGVFeHRyYTogdGhpcy5wcm9wcy5nZXREYXRlRXh0cmEsXG4gICAgICByZWY6IGRvbSA9PiB7XG4gICAgICAgIGRhdGEuY29tcG9uZW50UmVmID0gZG9tIHx8IGRhdGEuY29tcG9uZW50UmVmIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgZGF0YS51cGRhdGVMYXlvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jb21wdXRlSGVpZ2h0KGRhdGEsIGRvbSk7XG4gICAgICAgIH07XG4gICAgICAgIGRhdGEudXBkYXRlTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbXB1dGVIZWlnaHQgPSAoZGF0YTogRGF0ZU1vZGVscy5Nb250aERhdGEsIHNpbmdsZU1vbnRoKSA9PiB7XG4gICAgaWYgKHNpbmdsZU1vbnRoICYmIHNpbmdsZU1vbnRoLndyYXBwZXJEaXZET00pIHtcbiAgICAgIGlmICghZGF0YS5oZWlnaHQgJiYgIXNpbmdsZU1vbnRoLndyYXBwZXJEaXZET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb21wdXRlSGVpZ2h0KGRhdGEsIHNpbmdsZU1vbnRoKSwgNTAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGF0YS5oZWlnaHQgPSBzaW5nbGVNb250aC53cmFwcGVyRGl2RE9NLmNsaWVudEhlaWdodCB8fCBkYXRhLmhlaWdodCB8fCAwO1xuICAgICAgZGF0YS55ID0gc2luZ2xlTW9udGgud3JhcHBlckRpdkRPTS5vZmZzZXRUb3AgfHwgZGF0YS55IHx8IDA7XG4gICAgfVxuICB9XG5cbiAgc2V0TGF5b3V0ID0gKGRvbTogSFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICBpZiAoZG9tKSB7XG4gICAgICBjb25zdCB7IG9uTGF5b3V0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgb25MYXlvdXQoZG9tLmNsaWVudEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSB0aGlzLmNyZWF0ZU9uU2Nyb2xsKCk7XG4gICAgICBkb20ub25zY3JvbGwgPSBldnQgPT4ge1xuICAgICAgICBzY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICBjbGllbnQ6IGRvbS5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgZnVsbDogKGV2dC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50KS5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgdG9wOiAoZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTERpdkVsZW1lbnQpLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgc2V0UGFuZWwgPSAoZG9tOiBIVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMuX3BhbmVsID0gZG9tO1xuICB9XG5cbiAgb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5fbGFzdFkgPSBldmVudC50b3VjaGVzWzBdLnNjcmVlblkgfHwgZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICB0aGlzLl9kZWx0YSA9IHRoaXMuX2luaXREZWx0YTtcbiAgfVxuXG4gIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgZWxlID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBjb25zdCBpc1JlYWNoVG9wID0gZWxlLnNjcm9sbFRvcCA9PT0gMDtcblxuICAgIGlmIChpc1JlYWNoVG9wKSB7XG4gICAgICB0aGlzLl9kZWx0YSA9IChldmVudC50b3VjaGVzWzBdLnNjcmVlblkgfHwgZXZlbnQudG91Y2hlc1swXS5wYWdlWSkgLSB0aGlzLl9sYXN0WTtcbiAgICAgIGlmICh0aGlzLl9kZWx0YSA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMuX2RlbHRhID4gODApIHtcbiAgICAgICAgICB0aGlzLl9kZWx0YSA9IDgwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybSh0aGlzLl9wYW5lbC5zdHlsZSwgYHRyYW5zbGF0ZTNkKDAsJHt0aGlzLl9kZWx0YX1weCwwKWApO1xuICAgIH1cbiAgfVxuXG4gIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICB0aGlzLm9uRmluaXNoKCk7XG4gIH1cblxuICBvbkZpbmlzaCgpIHtcbiAgICBpZiAodGhpcy5fZGVsdGEgPiA0MCAmJiB0aGlzLmNhbkxvYWRQcmV2KCkpIHtcbiAgICAgIHRoaXMuZ2VuTW9udGhEYXRhKHRoaXMuc3RhdGUubW9udGhzWzBdLmZpcnN0RGF0ZSwgLTEpO1xuXG4gICAgICB0aGlzLnZpc2libGVNb250aCA9IHRoaXMuc3RhdGUubW9udGhzLnNsaWNlKDAsIHRoaXMucHJvcHMuaW5pdGFsTW9udGhzKTtcblxuICAgICAgdGhpcy5zdGF0ZS5tb250aHMuZm9yRWFjaChtID0+IHtcbiAgICAgICAgaWYgKG0udXBkYXRlTGF5b3V0KSB7XG4gICAgICAgICAgbS51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRoaXMuX3BhbmVsLnN0eWxlLCBgdHJhbnNsYXRlM2QoMCwwLDApYCk7XG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uKHRoaXMuX3BhbmVsLnN0eWxlLCAnLjNzJyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcGFuZWwpIHtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uKHRoaXMuX3BhbmVsLnN0eWxlLCAnJyk7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcbiAgfVxuXG4gIHNldFRyYW5zZm9ybShub2RlU3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24sIHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHZhbHVlO1xuICAgIG5vZGVTdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICBub2RlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdmFsdWU7XG4gIH1cblxuICBzZXRUcmFuc2l0aW9uKG5vZGVTdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgdmFsdWU6IGFueSkge1xuICAgIG5vZGVTdHlsZS50cmFuc2l0aW9uID0gdmFsdWU7XG4gICAgbm9kZVN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB2YWx1ZTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICAgIHRoaXMuc2V0TGF5b3V0KHRoaXMubGF5b3V0RG9tLm5hdGl2ZUVsZW1lbnQpO1xuICAgIHRoaXMuc2V0UGFuZWwodGhpcy5wYW5lbERvbS5uYXRpdmVFbGVtZW50KTtcbiAgfVxufVxuIl19