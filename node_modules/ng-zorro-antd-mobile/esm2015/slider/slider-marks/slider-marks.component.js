import { __decorate, __metadata } from "tslib";
import { Component, OnInit, ElementRef, Input, Output, EventEmitter, AfterViewInit, HostBinding, ViewEncapsulation } from '@angular/core';
let SliderMarksComponent = class SliderMarksComponent {
    constructor(_elf) {
        this._elf = _elf;
        this.markArray = [];
        this._min = 0;
        this._max = 100;
        this._marks = {};
        this._included = true;
        this._className = 'am-slider-mark';
        this.onChange = new EventEmitter();
        this.onAfterChange = new EventEmitter();
    }
    set min(value) {
        if (value && value <= this._max) {
            this._min = value;
        }
    }
    set max(value) {
        if (value && value >= this._min) {
            this._max = value;
        }
    }
    set marks(value) {
        this._marks = value;
    }
    set included(value) {
        this._included = value;
    }
    set upperBound(value) {
        if (value && value !== this._upperBound) {
            this._upperBound = value;
            this.setActiveCls();
        }
    }
    set lowerBound(value) {
        if (value && value !== this.lowerBound) {
            this._lowerBound = value;
            this.setActiveCls();
        }
    }
    get class() {
        return this._className;
    }
    getMarks(marksKeys) {
        this.markArray = [];
        marksKeys
            .map(parseFloat)
            .sort((a, b) => a - b)
            .map(point => {
            const markItem = {
                markLabel: '',
                point: '',
                className: {},
                style: {}
            };
            const markPoint = this._marks[point];
            const markPointIsObject = typeof markPoint === 'object';
            const markLabel = markPointIsObject ? markPoint.label : markPoint;
            if (!markLabel && markLabel !== 0) {
                return null;
            }
            const isActive = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            const markClassName = {
                [`${this._className}-text`]: true,
                [`${this._className}-text-active`]: isActive
            };
            const bottomStyle = {
                marginBottom: '-50%',
                bottom: `${((point - this._min) / this._range) * 100}%`
            };
            const leftStyle = {
                width: `${this._markWidth}%`,
                marginLeft: `${-this._markWidth / 2}%`,
                left: `${((point - this._min) / this._range) * 100}%`
            };
            const style = leftStyle;
            const markStyle = markPointIsObject ? Object.assign(Object.assign({}, style), markPoint.style) : style;
            markItem.markLabel = markLabel;
            markItem.point = point;
            markItem.className = Object.keys(markClassName).join(' ');
            markItem.style = markStyle;
            this.markArray.push(markItem);
        });
    }
    setActiveCls() {
        for (let i = 0; i < this.markArray.length; i++) {
            const point = this.markArray[i].point;
            const isActive = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            this.markArray[i].className = {
                [`${this._className}-text`]: true,
                [`${this._className}-text-active`]: isActive
            };
        }
    }
    setMarksLable() {
        for (let i = 0; i < this.markArray.length; i++) {
            const markEle = this._elf.nativeElement.getElementsByClassName(this._className + '-text')[i];
            markEle.innerHTML = this.markArray[i].markLabel;
        }
    }
    ngOnInit() {
        const marksKeys = Object.keys(this._marks);
        const marksCount = marksKeys.length;
        const unit = marksCount > 1 ? 100 / (marksCount - 1) : 100;
        this._markWidth = unit * 0.9;
        this._range = this._max - this._min;
        this.getMarks(marksKeys);
    }
    ngAfterViewInit() {
        this.setMarksLable();
    }
};
SliderMarksComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderMarksComponent.prototype, "min", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderMarksComponent.prototype, "max", null);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], SliderMarksComponent.prototype, "marks", null);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SliderMarksComponent.prototype, "included", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderMarksComponent.prototype, "upperBound", null);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], SliderMarksComponent.prototype, "lowerBound", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SliderMarksComponent.prototype, "onChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], SliderMarksComponent.prototype, "onAfterChange", void 0);
__decorate([
    HostBinding(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [])
], SliderMarksComponent.prototype, "class", null);
SliderMarksComponent = __decorate([
    Component({
        selector: 'SliderMarks, nzm-slider-marks',
        template: "<span *ngFor=\"let item of markArray\" [ngClass]=\"item.className\" [ngStyle]=\"item.style\"> </span>\n",
        encapsulation: ViewEncapsulation.None
    }),
    __metadata("design:paramtypes", [ElementRef])
], SliderMarksComponent);
export { SliderMarksComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLW1hcmtzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLXpvcnJvLWFudGQtbW9iaWxlLyIsInNvdXJjZXMiOlsic2xpZGVyL3NsaWRlci1tYXJrcy9zbGlkZXItbWFya3MuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULE1BQU0sRUFDTixVQUFVLEVBQ1YsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osYUFBYSxFQUNiLFdBQVcsRUFDWCxpQkFBaUIsRUFDbEIsTUFBTSxlQUFlLENBQUM7QUFPdkIsSUFBYSxvQkFBb0IsR0FBakMsTUFBYSxvQkFBb0I7SUF5RC9CLFlBQW9CLElBQWdCO1FBQWhCLFNBQUksR0FBSixJQUFJLENBQVk7UUF4RHBDLGNBQVMsR0FBZSxFQUFFLENBQUM7UUFFbkIsU0FBSSxHQUFXLENBQUMsQ0FBQztRQUNqQixTQUFJLEdBQVcsR0FBRyxDQUFDO1FBQ25CLFdBQU0sR0FBVyxFQUFFLENBQUM7UUFDcEIsY0FBUyxHQUFZLElBQUksQ0FBQztRQUMxQixlQUFVLEdBQVcsZ0JBQWdCLENBQUM7UUF5QzlDLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBTyxDQUFDO1FBRW5DLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQU8sQ0FBQztJQU9ELENBQUM7SUEzQ3hDLElBQUksR0FBRyxDQUFDLEtBQWE7UUFDbkIsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDL0IsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7U0FDbkI7SUFDSCxDQUFDO0lBRUQsSUFBSSxHQUFHLENBQUMsS0FBYTtRQUNuQixJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztTQUNuQjtJQUNILENBQUM7SUFFRCxJQUFJLEtBQUssQ0FBQyxL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O0lBREMsS0FBSyxFQUFFOzs7c0RBTVA7QUFFRDtJQURDLE1BQU0sRUFBRTs7c0RBQzBCO0FBRW5DO0lBREMsTUFBTSxFQUFFOzsyREFDK0I7QUFHeEM7SUFEQyxXQUFXLEVBQUU7OztpREFHYjtBQXZEVSxvQkFBb0I7SUFMaEMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLCtCQUErQjtRQUN6QyxtSEFBNEM7UUFDNUMsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7S0FDdEMsQ0FBQztxQ0EwRDBCLFVBQVU7R0F6RHpCLG9CQUFvQixDQXVJaEM7U0F2SVksb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBPbkluaXQsXG4gIEVsZW1lbnRSZWYsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIEV2ZW50RW1pdHRlcixcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgSG9zdEJpbmRpbmcsXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdTbGlkZXJNYXJrcywgbnptLXNsaWRlci1tYXJrcycsXG4gIHRlbXBsYXRlVXJsOiAnLi9zbGlkZXItbWFya3MuY29tcG9uZW50Lmh0bWwnLFxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFNsaWRlck1hcmtzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0IHtcbiAgbWFya0FycmF5OiBBcnJheTxhbnk+ID0gW107XG5cbiAgcHJpdmF0ZSBfbWluOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9tYXg6IG51bWJlciA9IDEwMDtcbiAgcHJpdmF0ZSBfbWFya3M6IG9iamVjdCA9IHt9O1xuICBwcml2YXRlIF9pbmNsdWRlZDogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgX2NsYXNzTmFtZTogc3RyaW5nID0gJ2FtLXNsaWRlci1tYXJrJztcbiAgcHJpdmF0ZSBfdXBwZXJCb3VuZDogbnVtYmVyO1xuICBwcml2YXRlIF9sb3dlckJvdW5kOiBudW1iZXI7XG4gIHByaXZhdGUgX3JhbmdlOiBudW1iZXI7XG4gIHByaXZhdGUgX21hcmtXaWR0aDogbnVtYmVyO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBtaW4odmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSA8PSB0aGlzLl9tYXgpIHtcbiAgICAgIHRoaXMuX21pbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBASW5wdXQoKVxuICBzZXQgbWF4KHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUgPj0gdGhpcy5fbWluKSB7XG4gICAgICB0aGlzLl9tYXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IG1hcmtzKHZhbHVlOiBvYmplY3QpIHtcbiAgICB0aGlzLl9tYXJrcyA9IHZhbHVlO1xuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBpbmNsdWRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2luY2x1ZGVkID0gdmFsdWU7XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IHVwcGVyQm91bmQodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gdGhpcy5fdXBwZXJCb3VuZCkge1xuICAgICAgdGhpcy5fdXBwZXJCb3VuZCA9IHZhbHVlO1xuICAgICAgdGhpcy5zZXRBY3RpdmVDbHMoKTtcbiAgICB9XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IGxvd2VyQm91bmQodmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICB0aGlzLl9sb3dlckJvdW5kID0gdmFsdWU7XG4gICAgICB0aGlzLnNldEFjdGl2ZUNscygpO1xuICAgIH1cbiAgfVxuICBAT3V0cHV0KClcbiAgb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgQE91dHB1dCgpXG4gIG9uQWZ0ZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBASG9zdEJpbmRpbmcoKVxuICBnZXQgY2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZjogRWxlbWVudFJlZikge31cblxuICBnZXRNYXJrcyhtYXJrc0tleXMpIHtcbiAgICB0aGlzLm1hcmtBcnJheSA9IFtdO1xuICAgIG1hcmtzS2V5c1xuICAgICAgLm1hcChwYXJzZUZsb2F0KVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgLm1hcChwb2ludCA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtJdGVtID0ge1xuICAgICAgICAgIG1hcmtMYWJlbDogJycsXG4gICAgICAgICAgcG9pbnQ6ICcnLFxuICAgICAgICAgIGNsYXNzTmFtZToge30sXG4gICAgICAgICAgc3R5bGU6IHt9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1hcmtQb2ludCA9IHRoaXMuX21hcmtzW3BvaW50XTtcbiAgICAgICAgY29uc3QgbWFya1BvaW50SXNPYmplY3QgPSB0eXBlb2YgbWFya1BvaW50ID09PSAnb2JqZWN0JztcbiAgICAgICAgY29uc3QgbWFya0xhYmVsID0gbWFya1BvaW50SXNPYmplY3QgPyBtYXJrUG9pbnQubGFiZWwgOiBtYXJrUG9pbnQ7XG4gICAgICAgIGlmICghbWFya0xhYmVsICYmIG1hcmtMYWJlbCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWN0aXZlID1cbiAgICAgICAgICAoIXRoaXMuX2luY2x1ZGVkICYmIHBvaW50ID09PSB0aGlzLl91cHBlckJvdW5kKSB8fFxuICAgICAgICAgICh0aGlzLl9pbmNsdWRlZCAmJiBwb2ludCA8PSB0aGlzLl91cHBlckJvdW5kICYmIHBvaW50ID49IHRoaXMuX2xvd2VyQm91bmQpO1xuICAgICAgICBjb25zdCBtYXJrQ2xhc3NOYW1lID0ge1xuICAgICAgICAgIFtgJHt0aGlzLl9jbGFzc05hbWV9LXRleHRgXTogdHJ1ZSxcbiAgICAgICAgICBbYCR7dGhpcy5fY2xhc3NOYW1lfS10ZXh0LWFjdGl2ZWBdOiBpc0FjdGl2ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib3R0b21TdHlsZSA9IHtcbiAgICAgICAgICBtYXJnaW5Cb3R0b206ICctNTAlJyxcbiAgICAgICAgICBib3R0b206IGAkeygocG9pbnQgLSB0aGlzLl9taW4pIC8gdGhpcy5fcmFuZ2UpICogMTAwfSVgXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxlZnRTdHlsZSA9IHtcbiAgICAgICAgICB3aWR0aDogYCR7dGhpcy5fbWFya1dpZHRofSVgLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IGAkey10aGlzLl9tYXJrV2lkdGggLyAyfSVgLFxuICAgICAgICAgIGxlZnQ6IGAkeygocG9pbnQgLSB0aGlzLl9taW4pIC8gdGhpcy5fcmFuZ2UpICogMTAwfSVgXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbGVmdFN0eWxlO1xuICAgICAgICBjb25zdCBtYXJrU3R5bGUgPSBtYXJrUG9pbnRJc09iamVjdCA/IHsgLi4uc3R5bGUsIC4uLm1hcmtQb2ludC5zdHlsZSB9IDogc3R5bGU7XG4gICAgICAgIG1hcmtJdGVtLm1hcmtMYWJlbCA9IG1hcmtMYWJlbDtcbiAgICAgICAgbWFya0l0ZW0ucG9pbnQgPSBwb2ludDtcbiAgICAgICAgbWFya0l0ZW0uY2xhc3NOYW1lID0gT2JqZWN0LmtleXMobWFya0NsYXNzTmFtZSkuam9pbignICcpO1xuICAgICAgICBtYXJrSXRlbS5zdHlsZSA9IG1hcmtTdHlsZTtcbiAgICAgICAgdGhpcy5tYXJrQXJyYXkucHVzaChtYXJrSXRlbSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHNldEFjdGl2ZUNscygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHRoaXMubWFya0FycmF5W2ldLnBvaW50O1xuICAgICAgY29uc3QgaXNBY3RpdmUgPVxuICAgICAgICAoIXRoaXMuX2luY2x1ZGVkICYmIHBvaW50ID09PSB0aGlzLl91cHBlckJvdW5kKSB8fFxuICAgICAgICAodGhpcy5faW5jbHVkZWQgJiYgcG9pbnQgPD0gdGhpcy5fdXBwZXJCb3VuZCAmJiBwb2ludCA+PSB0aGlzLl9sb3dlckJvdW5kKTtcbiAgICAgIHRoaXMubWFya0FycmF5W2ldLmNsYXNzTmFtZSA9IHtcbiAgICAgICAgW2Ake3RoaXMuX2NsYXNzTmFtZX0tdGV4dGBdOiB0cnVlLFxuICAgICAgICBbYCR7dGhpcy5fY2xhc3NOYW1lfS10ZXh0LWFjdGl2ZWBdOiBpc0FjdGl2ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBzZXRNYXJrc0xhYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hcmtFbGUgPSB0aGlzLl9lbGYubmF0aXZlRWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHRoaXMuX2NsYXNzTmFtZSArICctdGV4dCcpW2ldO1xuICAgICAgbWFya0VsZS5pbm5lckhUTUwgPSB0aGlzLm1hcmtBcnJheVtpXS5tYXJrTGFiZWw7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgY29uc3QgbWFya3NLZXlzID0gT2JqZWN0LmtleXModGhpcy5fbWFya3MpO1xuICAgIGNvbnN0IG1hcmtzQ291bnQgPSBtYXJrc0tleXMubGVuZ3RoO1xuICAgIGNvbnN0IHVuaXQgPSBtYXJrc0NvdW50ID4gMSA/IDEwMCAvIChtYXJrc0NvdW50IC0gMSkgOiAxMDA7XG4gICAgdGhpcy5fbWFya1dpZHRoID0gdW5pdCAqIDAuOTtcbiAgICB0aGlzLl9yYW5nZSA9IHRoaXMuX21heCAtIHRoaXMuX21pbjtcbiAgICB0aGlzLmdldE1hcmtzKG1hcmtzS2V5cyk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zZXRNYXJrc0xhYmxlKCk7XG4gIH1cbn1cbiJdfQ==