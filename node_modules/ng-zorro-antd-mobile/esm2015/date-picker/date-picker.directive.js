var DatePickerDirective_1;
import { __decorate, __metadata } from "tslib";
import { Input, Output, OnInit, Injector, OnChanges, OnDestroy, Directive, forwardRef, EventEmitter, HostListener, ComponentRef, SimpleChanges, ComponentFactory, ViewContainerRef, ComponentFactoryResolver } from '@angular/core';
import { DatePickerComponent } from './date-picker.component';
import { DatePickerOptions } from './date-picker-options.provider';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
let DatePickerDirective = DatePickerDirective_1 = class DatePickerDirective {
    constructor(_viewContainerRef, _defaultOptions, _cfr) {
        this._viewContainerRef = _viewContainerRef;
        this._defaultOptions = _defaultOptions;
        this._cfr = _cfr;
        this._eventListeners = [];
        this.minuteStep = 1;
        this.value = new Date();
        this.onVisibleChange = new EventEmitter(true);
        this.onValueChange = new EventEmitter();
        this.onOk = new EventEmitter();
        this.onDismiss = new EventEmitter();
    }
    togglePicker() {
        if (!this.picker) {
            this.showPicker();
        }
        else {
            this.hidePicker();
        }
    }
    showPicker() {
        if (!this.picker && !this.disabled) {
            setTimeout(() => {
                this._eventListeners = [];
            });
            const options = new DatePickerOptions();
            Object.assign(options, this._defaultOptions, {
                hidePicker: (event) => {
                    this.hidePicker();
                },
                updateNgModel: (value) => {
                    if (this._ngModelOnChange) {
                        this.value = value;
                        this._ngModelOnChange(value);
                    }
                }
            });
            const optionalParams = [
                'mode',
                'minDate',
                'maxDate',
                'minuteStep',
                'value',
                'mask',
                'title',
                'okText',
                'dismissText',
                'disabled',
                'locale',
                'appendToBody',
                'showErrorToast',
                'showErrorToastInterval',
                'onOk',
                'onDismiss',
                'onValueChange'
            ];
            optionalParams.forEach(param => {
                if (typeof this[param] !== 'undefined') {
                    options[param] = this[param];
                }
            });
            const componentFactory = this._cfr.resolveComponentFactory(DatePickerComponent);
            const childInjector = Injector.create([
                {
                    provide: DatePickerOptions,
                    useValue: options
                }
            ]);
            this.picker = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                this.appendToBodyElement = document.body.appendChild(this.picker.location.nativeElement);
            }
            this.onVisibleChange.emit(true);
        }
    }
    hidePicker() {
        if (this.appendToBodyElement) {
            document.body.removeChild(this.appendToBodyElement);
            this.appendToBodyElement = null;
        }
        if (this.picker) {
            this.picker.destroy();
            delete this.picker;
            this.onVisibleChange.emit(false);
            this._eventListeners.forEach(fn => fn());
            this._eventListeners = [];
        }
    }
    writeValue(value) {
        this.value = value;
    }
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngOnInit() {
        this.onVisibleChange.emit(false);
    }
    ngOnChanges(changes) {
        if (changes.isOpen) {
            if (changes.isOpen.currentValue === true) {
                this.showPicker();
            }
            else {
                this.hidePicker();
            }
        }
    }
    ngOnDestroy() {
        this.hidePicker();
    }
};
DatePickerDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DatePickerOptions },
    { type: ComponentFactoryResolver }
];
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "isOpen", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "mode", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "minDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "maxDate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "use12Hours", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DatePickerDirective.prototype, "minuteStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], DatePickerDirective.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "mask", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "okText", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], DatePickerDirective.prototype, "dismissText", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "disabled", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], DatePickerDirective.prototype, "locale", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "appendToBody", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], DatePickerDirective.prototype, "showErrorToast", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], DatePickerDirective.prototype, "showErrorToastInterval", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerDirective.prototype, "onVisibleChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerDirective.prototype, "onValueChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerDirective.prototype, "onOk", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], DatePickerDirective.prototype, "onDismiss", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], DatePickerDirective.prototype, "togglePicker", null);
DatePickerDirective = DatePickerDirective_1 = __decorate([
    Directive({
        selector: '[DatePicker]',
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => DatePickerDirective_1),
                multi: true
            }
        ]
    }),
    __metadata("design:paramtypes", [ViewContainerRef,
        DatePickerOptions,
        ComponentFactoryResolver])
], DatePickerDirective);
export { DatePickerDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctem9ycm8tYW50ZC1tb2JpbGUvIiwic291cmNlcyI6WyJkYXRlLXBpY2tlci9kYXRlLXBpY2tlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQ0wsS0FBSyxFQUNMLE1BQU0sRUFDTixNQUFNLEVBQ04sUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osWUFBWSxFQUNaLFlBQVksRUFDWixhQUFhLEVBQ2IsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDekIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBV3pFLElBQWEsbUJBQW1CLDJCQUFoQyxNQUFhLG1CQUFtQjtJQXlEOUIsWUFDVSxpQkFBbUMsRUFDbkMsZUFBa0MsRUFDbEMsSUFBOEI7UUFGOUIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFrQjtRQUNuQyxvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7UUFDbEMsU0FBSSxHQUFKLElBQUksQ0FBMEI7UUF6RGhDLG9CQUFlLEdBQXNCLEVBQUUsQ0FBQztRQWVoRCxlQUFVLEdBQVcsQ0FBQyxDQUFDO1FBRXZCLFVBQUssR0FBUyxJQUFJLElBQUksRUFBRSxDQUFDO1FBb0J6QixvQkFBZSxHQUEwQixJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVoRSxrQkFBYSxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDO1FBRXRELFNBQUksR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUU3QyxjQUFTLEdBQXNCLElBQUksWUFBWSxF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OlsiaW1wb3J0IHtcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgT25Jbml0LFxuICBJbmplY3RvcixcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIERpcmVjdGl2ZSxcbiAgZm9yd2FyZFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0TGlzdGVuZXIsXG4gIENvbXBvbmVudFJlZixcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgQ29tcG9uZW50RmFjdG9yeSxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZS1waWNrZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERhdGVQaWNrZXJPcHRpb25zIH0gZnJvbSAnLi9kYXRlLXBpY2tlci1vcHRpb25zLnByb3ZpZGVyJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tEYXRlUGlja2VyXScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZVBpY2tlckRpcmVjdGl2ZSksXG4gICAgICBtdWx0aTogdHJ1ZVxuICAgIH1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlja2VyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkNoYW5nZXMsIE9uSW5pdCwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICBwaWNrZXI6IENvbXBvbmVudFJlZjxEYXRlUGlja2VyQ29tcG9uZW50PjtcbiAgYXBwZW5kVG9Cb2R5RWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgX2V2ZW50TGlzdGVuZXJzOiBBcnJheTwoKSA9PiB2b2lkPiA9IFtdO1xuICBwcml2YXRlIF9uZ01vZGVsT25DaGFuZ2U6ICh2YWx1ZTogRGF0ZSkgPT4ge307XG4gIHByaXZhdGUgX25nTW9kZWxPblRvdWNoZWQ6ICgpID0+IHt9O1xuXG4gIEBJbnB1dCgpXG4gIGlzT3BlbjogYm9vbGVhbjtcbiAgQElucHV0KClcbiAgbW9kZTogc3RyaW5nO1xuICBASW5wdXQoKVxuICBtaW5EYXRlOiBzdHJpbmc7XG4gIEBJbnB1dCgpXG4gIG1heERhdGU6IHN0cmluZztcbiAgQElucHV0KClcbiAgdXNlMTJIb3VyczogYm9vbGVhbjtcbiAgQElucHV0KClcbiAgbWludXRlU3RlcDogbnVtYmVyID0gMTtcbiAgQElucHV0KClcbiAgdmFsdWU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICBASW5wdXQoKVxuICBtYXNrOiBib29sZWFuO1xuICBASW5wdXQoKVxuICB0aXRsZTogc3RyaW5nO1xuICBASW5wdXQoKVxuICBva1RleHQ6IHN0cmluZztcbiAgQElucHV0KClcbiAgZGlzbWlzc1RleHQ6IHN0cmluZztcbiAgQElucHV0KClcbiAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpXG4gIGxvY2FsZTogYW55O1xuICBASW5wdXQoKVxuICBhcHBlbmRUb0JvZHk6IGJvb2xlYW47XG4gIEBJbnB1dCgpXG4gIHNob3dFcnJvclRvYXN0OiBib29sZWFuO1xuICBASW5wdXQoKVxuICBzaG93RXJyb3JUb2FzdEludGVydmFsOiBudW1iZXI7XG4gIEBPdXRwdXQoKVxuICBvblZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gIEBPdXRwdXQoKVxuICBvblZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgpXG4gIG9uT2s6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KClcbiAgb25EaXNtaXNzOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIHRvZ2dsZVBpY2tlcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGlja2VyKSB7XG4gICAgICB0aGlzLnNob3dQaWNrZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlUGlja2VyKCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIF9kZWZhdWx0T3B0aW9uczogRGF0ZVBpY2tlck9wdGlvbnMsXG4gICAgcHJpdmF0ZSBfY2ZyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgKSB7fVxuXG4gIHNob3dQaWNrZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBpY2tlciAmJiAhdGhpcy5kaXNhYmxlZCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gW107XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IG5ldyBEYXRlUGlja2VyT3B0aW9ucygpO1xuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLl9kZWZhdWx0T3B0aW9ucywge1xuICAgICAgICBoaWRlUGlja2VyOiAoZXZlbnQpOiB2b2lkID0+IHtcbiAgICAgICAgICB0aGlzLmhpZGVQaWNrZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlTmdNb2RlbDogKHZhbHVlOiBEYXRlKTogdm9pZCA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX25nTW9kZWxPbkNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fbmdNb2RlbE9uQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvcHRpb25hbFBhcmFtczogQXJyYXk8a2V5b2YgRGF0ZVBpY2tlckRpcmVjdGl2ZT4gPSBbXG4gICAgICAgICdtb2RlJyxcbiAgICAgICAgJ21pbkRhdGUnLFxuICAgICAgICAnbWF4RGF0ZScsXG4gICAgICAgICdtaW51dGVTdGVwJyxcbiAgICAgICAgJ3ZhbHVlJyxcbiAgICAgICAgJ21hc2snLFxuICAgICAgICAndGl0bGUnLFxuICAgICAgICAnb2tUZXh0JyxcbiAgICAgICAgJ2Rpc21pc3NUZXh0JyxcbiAgICAgICAgJ2Rpc2FibGVkJyxcbiAgICAgICAgJ2xvY2FsZScsXG4gICAgICAgICdhcHBlbmRUb0JvZHknLFxuICAgICAgICAnc2hvd0Vycm9yVG9hc3QnLFxuICAgICAgICAnc2hvd0Vycm9yVG9hc3RJbnRlcnZhbCcsXG4gICAgICAgICdvbk9rJyxcbiAgICAgICAgJ29uRGlzbWlzcycsXG4gICAgICAgICdvblZhbHVlQ2hhbmdlJ1xuICAgICAgXTtcbiAgICAgIG9wdGlvbmFsUGFyYW1zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNbcGFyYW1dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIChvcHRpb25zIGFzIGFueSlbcGFyYW1dID0gdGhpc1twYXJhbV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxEYXRlUGlja2VyQ29tcG9uZW50PiA9IHRoaXMuX2Nmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShcbiAgICAgICAgRGF0ZVBpY2tlckNvbXBvbmVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNoaWxkSW5qZWN0b3IgPSBJbmplY3Rvci5jcmVhdGUoW1xuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogRGF0ZVBpY2tlck9wdGlvbnMsXG4gICAgICAgICAgdXNlVmFsdWU6IG9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgICB0aGlzLnBpY2tlciA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KFxuICAgICAgICBjb21wb25lbnRGYWN0b3J5LFxuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmxlbmd0aCxcbiAgICAgICAgY2hpbGRJbmplY3RvclxuICAgICAgKTtcbiAgICAgIGlmIChvcHRpb25zLmFwcGVuZFRvQm9keSkge1xuICAgICAgICB0aGlzLmFwcGVuZFRvQm9keUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucGlja2VyLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5vblZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBoaWRlUGlja2VyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFwcGVuZFRvQm9keUVsZW1lbnQpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5hcHBlbmRUb0JvZHlFbGVtZW50KTtcbiAgICAgIHRoaXMuYXBwZW5kVG9Cb2R5RWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgdGhpcy5waWNrZXIuZGVzdHJveSgpO1xuICAgICAgZGVsZXRlIHRoaXMucGlja2VyO1xuICAgICAgdGhpcy5vblZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IERhdGUpID0+IHt9KTogdm9pZCB7XG4gICAgdGhpcy5fbmdNb2RlbE9uQ2hhbmdlID0gZm47XG4gIH1cblxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4ge30pOiB2b2lkIHtcbiAgICB0aGlzLl9uZ01vZGVsT25Ub3VjaGVkID0gZm47XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMub25WaXNpYmxlQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzLmlzT3Blbikge1xuICAgICAgaWYgKGNoYW5nZXMuaXNPcGVuLmN1cnJlbnRWYWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNob3dQaWNrZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGlkZVBpY2tlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuaGlkZVBpY2tlcigpO1xuICB9XG59XG4iXX0=