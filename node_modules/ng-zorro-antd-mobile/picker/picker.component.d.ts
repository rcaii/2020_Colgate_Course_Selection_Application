import { OnInit, OnDestroy, ElementRef, AfterViewInit } from '@angular/core';
import { PickerOptions } from './picker-options.provider';
import { LocaleProviderService } from '../locale-provider/locale-provider.service';
import { PickerRef } from './picker-ref.class';
import * as ɵngcc0 from '@angular/core';
export declare class PickerComponent<T = any, R = any> extends PickerRef<T, R> implements OnInit, AfterViewInit, OnDestroy {
    elementRef: ElementRef;
    options: PickerOptions;
    private _localeProviderService;
    transitionName: string;
    maskTransitionName: string;
    startY: number;
    differY: number;
    currentY: number;
    len: number;
    dom: any;
    index: number;
    maxY: number;
    lineHeight: number;
    dataForRender: any[];
    selectedTarget: any[];
    isMouseDown: boolean;
    Velocity: {
        record: (y: any) => void;
        getVelocity: (y: any) => number;
    };
    currentPicker: any;
    private _unsubscribe$;
    private _picker;
    panstart(event: any): void;
    panmove(event: any): void;
    panend(event: any): void;
    constructor(elementRef: ElementRef, options: PickerOptions, _localeProviderService: LocaleProviderService);
    onChange: (_: any[]) => void;
    init(): void;
    getInitValueIndex(dataTemp: any): void;
    reloadPicker(): void;
    generateArrayData(targetArr: any): any[];
    checkArrayDeep(parent: any, init?: boolean): void;
    ok(): void;
    combineReslut(): any[];
    cancel(): void;
    setTransitionName(): void;
    setCurrentSelected(target: any, index: any): void;
    getInstance(): PickerComponent;
    getElement(): HTMLElement;
    close(): void;
    destroy(): void;
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PickerComponent<any, any>, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<PickerComponent<any, any>, "Picker", never, {}, {}, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlja2VyLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJwaWNrZXIuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT25Jbml0LCBPbkRlc3Ryb3ksIEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBpY2tlck9wdGlvbnMgfSBmcm9tICcuL3BpY2tlci1vcHRpb25zLnByb3ZpZGVyJztcbmltcG9ydCB7IExvY2FsZVByb3ZpZGVyU2VydmljZSB9IGZyb20gJy4uL2xvY2FsZS1wcm92aWRlci9sb2NhbGUtcHJvdmlkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQaWNrZXJSZWYgfSBmcm9tICcuL3BpY2tlci1yZWYuY2xhc3MnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGlja2VyQ29tcG9uZW50PFQgPSBhbnksIFIgPSBhbnk+IGV4dGVuZHMgUGlja2VyUmVmPFQsIFI+IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gICAgb3B0aW9uczogUGlja2VyT3B0aW9ucztcbiAgICBwcml2YXRlIF9sb2NhbGVQcm92aWRlclNlcnZpY2U7XG4gICAgdHJhbnNpdGlvbk5hbWU6IHN0cmluZztcbiAgICBtYXNrVHJhbnNpdGlvbk5hbWU6IHN0cmluZztcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBkaWZmZXJZOiBudW1iZXI7XG4gICAgY3VycmVudFk6IG51bWJlcjtcbiAgICBsZW46IG51bWJlcjtcbiAgICBkb206IGFueTtcbiAgICBpbmRleDogbnVtYmVyO1xuICAgIG1heFk6IG51bWJlcjtcbiAgICBsaW5lSGVpZ2h0OiBudW1iZXI7XG4gICAgZGF0YUZvclJlbmRlcjogYW55W107XG4gICAgc2VsZWN0ZWRUYXJnZXQ6IGFueVtdO1xuICAgIGlzTW91c2VEb3duOiBib29sZWFuO1xuICAgIFZlbG9jaXR5OiB7XG4gICAgICAgIHJlY29yZDogKHk6IGFueSkgPT4gdm9pZDtcbiAgICAgICAgZ2V0VmVsb2NpdHk6ICh5OiBhbnkpID0+IG51bWJlcjtcbiAgICB9O1xuICAgIGN1cnJlbnRQaWNrZXI6IGFueTtcbiAgICBwcml2YXRlIF91bnN1YnNjcmliZSQ7XG4gICAgcHJpdmF0ZSBfcGlja2VyO1xuICAgIHBhbnN0YXJ0KGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIHBhbm1vdmUoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgcGFuZW5kKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIG9wdGlvbnM6IFBpY2tlck9wdGlvbnMsIF9sb2NhbGVQcm92aWRlclNlcnZpY2U6IExvY2FsZVByb3ZpZGVyU2VydmljZSk7XG4gICAgb25DaGFuZ2U6IChfOiBhbnlbXSkgPT4gdm9pZDtcbiAgICBpbml0KCk6IHZvaWQ7XG4gICAgZ2V0SW5pdFZhbHVlSW5kZXgoZGF0YVRlbXA6IGFueSk6IHZvaWQ7XG4gICAgcmVsb2FkUGlja2VyKCk6IHZvaWQ7XG4gICAgZ2VuZXJhdGVBcnJheURhdGEodGFyZ2V0QXJyOiBhbnkpOiBhbnlbXTtcbiAgICBjaGVja0FycmF5RGVlcChwYXJlbnQ6IGFueSwgaW5pdD86IGJvb2xlYW4pOiB2b2lkO1xuICAgIG9rKCk6IHZvaWQ7XG4gICAgY29tYmluZVJlc2x1dCgpOiBhbnlbXTtcbiAgICBjYW5jZWwoKTogdm9pZDtcbiAgICBzZXRUcmFuc2l0aW9uTmFtZSgpOiB2b2lkO1xuICAgIHNldEN1cnJlbnRTZWxlY3RlZCh0YXJnZXQ6IGFueSwgaW5kZXg6IGFueSk6IHZvaWQ7XG4gICAgZ2V0SW5zdGFuY2UoKTogUGlja2VyQ29tcG9uZW50O1xuICAgIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnQ7XG4gICAgY2xvc2UoKTogdm9pZDtcbiAgICBkZXN0cm95KCk6IHZvaWQ7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xufVxuIl19